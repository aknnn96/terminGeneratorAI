<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Termin-Detektiv (Robuste Version)</title>
    
    <!-- Lade Tailwind CSS für modernes Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f7f7; }

        /* Custom Styles */
        /* Flexbox für vollen Viewport-Platz, um auf mobilen Geräten gut auszusehen */
        .chat-container { display: flex; flex-direction: column; height: 100vh; max-height: 100vh; overflow: hidden; }
        .chat-window { flex-grow: 1; overflow-y: auto; scroll-behavior: smooth; padding: 1rem; }
        
        .message-row { display: flex; margin-bottom: 0.75rem; }
        .user-message-row { justify-content: flex-end; }
        .bot-message-row { justify-content: flex-start; }
        
        /* Max-Breite auf 85% für bessere Lesbarkeit auf Desktop */
        .message { padding: 0.75rem 1rem; border-radius: 1.5rem; max-width: 85%; line-height: 1.4; word-wrap: break-word; font-size: 0.95rem; } 
        
        .user-message { 
            background-color: #DCF8C6; /* Helles Grün */
            color: #1F2937; 
            border-bottom-right-radius: 0.375rem; /* Weniger rund unten rechts */
        }
        .bot-message { 
            background-color: #E5E7EB; /* Helles Grau */
            color: #1F2937;
            border-bottom-left-radius: 0.375rem; /* Weniger rund unten links */
        }
        
        /* Style für strukturierte Termin-Ergebnisse */
        .structured-output {
            background-color: #ffffff;
            border: 1px solid #D1D5DB;
            padding: 1rem;
            margin-top: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .structured-output strong {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 1.1rem;
        }

        /* Loading Animation */
        .loading-dots div {
            width: 10px;
            height: 10px;
            background-color: #4B5563;
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: bounce 0.6s infinite alternate;
        }
        .loading-dots div:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots div:nth-child(3) { animation-delay: 0.4s; }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-5px); }
        }

        /* Image Preview Style */
        .image-preview-container {
            border: 1px solid #D1D5DB;
            border-radius: 0.75rem;
            padding: 0.5rem;
            background-color: #F9FAFB;
        }
        .image-preview-container img {
            max-height: 100px;
            width: auto;
            border-radius: 0.5rem;
        }
        
        /* Responsivität für kleine Bildschirme */
        @media (max-width: 640px) {
            .message { max-width: 95%; font-size: 0.9rem; }
            .message-input-area { padding: 0.5rem; }
        }
    </style>
    <!-- Konfiguriere Tailwind für 'Inter' und einfache Rounded Corners -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    borderRadius: {
                        '3xl': '1.5rem',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50">

    <div id="app" class="chat-container">
        
        <!-- Header mit Titel und Export-Button -->
        <header class="bg-white shadow-md p-4 flex justify-between items-center sticky top-0 z-10">
            <h1 class="text-xl font-bold text-gray-800 flex items-center">
                <span class="material-icons text-indigo-600 mr-2">calendar_today</span>
                AI Termin-Detektiv
            </h1>
            <div class="space-x-3">
                <button id="downloadChatButton" onclick="downloadChat()" 
                        class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-3 rounded-xl transition duration-150 ease-in-out shadow-lg text-sm flex items-center">
                    <span class="material-icons text-base mr-1">download</span>
                    Chat Export
                </button>
            </div>
        </header>

        <!-- Chat-Fenster -->
        <div id="chatWindow" class="chat-window flex flex-col space-y-3 p-4 bg-white overflow-y-auto">
            <!-- Nachrichten werden hier eingefügt -->
        </div>

        <!-- Ladeanzeige -->
        <div id="loadingIndicator" class="hidden p-4 bg-white">
            <div class="bot-message-row">
                <div class="message bg-gray-200 text-gray-700 shadow-md flex items-center">
                    <div class="loading-dots flex">
                        <div></div>
                        <div></div>
                        <div></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bildeingabe- und Text-Eingabe-Bereich -->
        <div class="message-input-area p-4 bg-gray-100 border-t border-gray-200">
            
            <!-- Bild-Vorschau-Bereich -->
            <div id="imagePreviewContainer" class="image-preview-container flex items-center justify-between mb-3 hidden">
                <div class="flex items-center space-x-3">
                    <img id="image-preview" src="" alt="Bild-Vorschau" class="h-20 w-auto rounded-lg object-cover">
                    <span id="image-filename" class="text-sm text-gray-600 truncate max-w-xs"></span>
                </div>
                <button id="cancel-upload" class="text-gray-500 hover:text-red-500 transition duration-150">
                    <span class="material-icons">close</span>
                </button>
            </div>

            <div class="flex items-end space-x-3">
                <!-- Bild-Upload Button -->
                <label for="fileInput" class="cursor-pointer text-gray-500 hover:text-indigo-600 transition duration-150 p-2 rounded-full hover:bg-gray-200">
                    <span class="material-icons text-3xl">image</span>
                    <input type="file" id="fileInput" accept="image/*" class="hidden">
                </label>

                <!-- Text-Eingabefeld -->
                <textarea id="userInput" 
                          placeholder="Termin-Details eingeben oder Bild hochladen..." 
                          rows="1" 
                          class="flex-grow resize-none p-3 border border-gray-300 rounded-2xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 overflow-hidden" 
                          style="max-height: 200px;"></textarea>
                
                <!-- Sende-Button -->
                <button id="sendButton" onclick="sendMessage()" disabled 
                        class="bg-indigo-500 text-white p-3 rounded-full shadow-lg transition-all duration-300 disabled:bg-indigo-300 disabled:opacity-70 hover:bg-indigo-600 flex-shrink-0">
                    <span class="material-icons">send</span>
                </button>
            </div>
        </div>

    </div>

    <!-- JavaScript-Logik -->
    <script>
    
    // --- Firestore/Firebase Initialisierung (NUR FÜR PERSISTENZ) ---
    // Die globalen Variablen __app_id, __firebase_config, und __initial_auth_token
    // werden automatisch von der Canvas-Umgebung bereitgestellt.
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, collection, query, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Debugging-Level setzen (optional)
    setLogLevel('Debug');

    let db;
    let auth;
    let userId = 'anon';
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-termin-detektiv-id';

    let isAuthReady = false;

    // Firebase Initialisierung
    async function initializeFirebase() {
        try {
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
            if (!firebaseConfig) {
                console.error("Firebase Config nicht gefunden. Der Chat-Verlauf wird NICHT gespeichert.");
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Anmelde-Logik
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Firebase Auth erfolgreich. User ID:", userId);
                } else {
                    userId = 'anon-' + crypto.randomUUID(); // Fallback für den unwahrscheinlichen Fall, dass keine Anmeldung erfolgt ist
                    console.warn("Anonyme oder unauthentifizierte Firebase-Sitzung. User ID:", userId);
                }
                isAuthReady = true;
                // Chat-Historie nach erfolgreicher Auth laden und Listener einrichten
                setupChatListener(); 
                initializeChat();
            });
            
        } catch (error) {
            console.error("Fehler bei der Firebase-Initialisierung:", error);
            // Trotz Fehler den Chat initialisieren (ohne Persistenz)
            isAuthReady = true;
            initializeChat();
        }
    }

    // Pfad zur Firestore-Sammlung (Private Daten)
    const getChatHistoryDocRef = () => {
        if (!db || !userId) return null;
        // Pfad: /artifacts/{appId}/users/{userId}/chatHistory/current
        return doc(db, 'artifacts', appId, 'users', userId, 'chatHistory', 'current');
    };

    // --- Chat-Logik und DOM-Elemente ---
    const chatWindow = document.getElementById('chatWindow');
    const userInput = document.getElementById('userInput');
    const sendButton = document.getElementById('sendButton');
    const fileInput = document.getElementById('fileInput');
    const imagePreviewContainer = document.getElementById('imagePreviewContainer');
    const loadingIndicator = document.getElementById('loadingIndicator');

    let chatHistory = [];
    let currentImageFile = null;

    // --- Firestore Lese- und Schreibfunktionen ---

    // Speichert den aktuellen Chat-Verlauf in Firestore
    async function saveChatHistory() {
        if (!isAuthReady || !db || !userId) return;

        try {
            const docRef = getChatHistoryDocRef();
            if (docRef) {
                 await setDoc(docRef, { history: JSON.stringify(chatHistory), updatedAt: new Date() });
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Chat-Historie:", error);
        }
    }

    // Richtet den Echtzeit-Listener für den Chat-Verlauf ein
    function setupChatListener() {
        const docRef = getChatHistoryDocRef();
        if (docRef) {
            onSnapshot(docRef, (doc) => {
                if (doc.exists()) {
                    try {
                        const loadedHistory = JSON.parse(doc.data().history);
                        if (JSON.stringify(loadedHistory) !== JSON.stringify(chatHistory)) {
                            chatHistory = loadedHistory;
                            renderChatHistory();
                        }
                    } catch (e) {
                        console.error("Fehler beim Parsen der geladenen Historie:", e);
                    }
                } else {
                    // Dokument existiert nicht, leere Historie initialisieren
                    chatHistory = [];
                    renderChatHistory();
                }
            }, (error) => {
                console.error("Fehler beim onSnapshot Listener:", error);
            });
        }
    }
    
    // Rendert den Chat-Verlauf neu
    function renderChatHistory() {
        chatWindow.innerHTML = ''; // Vorherige Nachrichten entfernen
        chatHistory.forEach(message => {
            const msgElement = createMessageElement(message);
            chatWindow.appendChild(msgElement);
        });
        scrollToBottom();
    }


    // --- UI Helfer-Funktionen ---

    // Scrollt zum unteren Ende des Chat-Fensters
    function scrollToBottom() {
        // Verzögerung, um sicherzustellen, dass DOM-Updates abgeschlossen sind (z.B. nach dem Laden eines Bildes)
        setTimeout(() => {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }, 10);
    }

    // Erstellt ein DOM-Element für eine Nachricht
    function createMessageElement(messageData) {
        const row = document.createElement('div');
        row.className = `message-row ${messageData.sender === 'user' ? 'user-message-row' : 'bot-message-row'}`;
        
        const contentContainer = document.createElement('div');
        
        if (messageData.imageUrl) {
            // Bild-Anzeige
            const imageEl = document.createElement('img');
            imageEl.src = messageData.imageUrl;
            imageEl.alt = "Vom Nutzer hochgeladenes Bild";
            imageEl.className = 'w-full max-h-64 object-contain rounded-xl mb-2 shadow-md';
            contentContainer.appendChild(imageEl);
        }

        const textEl = document.createElement('div');
        textEl.className = `message ${messageData.sender === 'user' ? 'user-message' : 'bot-message'} shadow-md`;
        
        // Fügt Markdown-Formatierung hinzu (fett, kursiv, Zeilenumbrüche)
        const formattedText = messageData.text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Fett
            .replace(/\*(.*?)\*/g, '<em>$1</em>')          // Kursiv
            .replace(/\n/g, '<br>');                        // Zeilenumbrüche
            
        textEl.innerHTML = formattedText;
        contentContainer.appendChild(textEl);

        // Strukturierte Termin-Ausgabe
        if (messageData.structuredResponse) {
            const structuredEl = document.createElement('div');
            structuredEl.className = 'structured-output';
            let html = '<h3 class="font-bold text-lg text-indigo-700 mb-2">Gefundene Termindaten:</h3>';
            
            // Schleife über die Schlüssel-Wert-Paare der strukturierten Antwort
            for (const key in messageData.structuredResponse) {
                let value = messageData.structuredResponse[key];
                // Schlüssel formatieren (z.B. "datum" zu "Datum")
                const formattedKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                
                html += `<div class="py-1 border-b border-gray-100 last:border-b-0">
                            <span class="font-semibold text-gray-700">${formattedKey}:</span> 
                            <span class="text-gray-600">${value || 'N/A'}</span>
                        </div>`;
            }
            structuredEl.innerHTML = html;
            contentContainer.appendChild(structuredEl);
        }

        row.appendChild(contentContainer);
        return row;
    }

    // Fügt eine Nachricht zur Historie und zum DOM hinzu (ohne Rendern)
    function addMessageToChat(text, sender, imageUrl, structuredResponse = null) {
        const messageData = { text, sender, imageUrl, structuredResponse };
        chatHistory.push(messageData);
        saveChatHistory();
        return messageData; // Gibt die hinzugefügte Nachricht zurück
    }

    // Zeigt die Ladeanzeige an
    function showLoading() {
        loadingIndicator.classList.remove('hidden');
        scrollToBottom();
    }

    // Versteckt die Ladeanzeige
    function hideLoading() {
        loadingIndicator.classList.add('hidden');
    }

    // Aktiviert/Deaktiviert den Sende-Button
    function toggleSendButton() {
        const text = userInput.value.trim();
        const hasImage = currentImageFile !== null;
        sendButton.disabled = !(text.length > 0 || hasImage);
    }

    // Setzt das Bild-Upload-Feld zurück
    function resetImageUpload() {
        currentImageFile = null;
        fileInput.value = '';
        imagePreviewContainer.classList.add('hidden');
        document.getElementById('image-preview').src = '';
        document.getElementById('image-filename').textContent = '';
    }

    // --- API Kommunikation ---

    // Konvertiert File-Objekt zu Base64-String
    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                // Entferne den Mime-Typ-Präfix
                const base64String = reader.result.split(',')[1];
                resolve(base64String);
            };
            reader.onerror = error => reject(error);
        });
    }

    // API-Endpunkt und Modell
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
    // Die API-Key-Variable ist leer, da sie im Canvas-Environment automatisch injiziert wird
    const GEMINI_API_KEY = ""; 
    const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";

    // Definiert die erwartete JSON-Struktur für die Termindaten
    const RESPONSE_SCHEMA = {
        type: "OBJECT",
        properties: {
            "datum": { "type": "STRING", "description": "Der extrahierte Termin in einem konsistenten Format (YYYY-MM-DD)." },
            "uhrzeit": { "type": "STRING", "description": "Die extrahierte Uhrzeit (HH:MM)." },
            "ort": { "type": "STRING", "description": "Der extrahierte Ort oder die Adresse." },
            "zweck": { "type": "STRING", "description": "Der Grund oder Zweck des Termins (z.B. Arztbesuch, Besprechung)." }
        },
        // WICHTIG: propertyOrdering muss existieren, um die Reihenfolge sicherzustellen
        "propertyOrdering": ["datum", "uhrzeit", "ort", "zweck"]
    };

    /**
     * Sendet die Nachricht und optional ein Bild an die Gemini API.
     * @param {string} userText - Der vom Benutzer eingegebene Text.
     * @param {File | null} imageFile - Das hochgeladene Bild, oder null.
     */
    async function getGeminiResponse(userText, imageFile) {
        let chatParts = [];

        // 1. System-Prompt: Definiert die Rolle des Models
        const systemPrompt = "Sie sind der 'AI Termin-Detektiv'. Ihre Aufgabe ist es, aus dem gegebenen Text oder Bild präzise und strukturierte Termininformationen zu extrahieren: Datum (YYYY-MM-DD), Uhrzeit (HH:MM), Ort und Zweck. Wenn Informationen fehlen, geben Sie 'N/A' an. Erzeugen Sie KEINEN reinen Text, sondern nur das erfragte JSON-Objekt. Wenn der Benutzer eine allgemeine Konversation führen möchte, ohne einen Termin zu nennen, antworten Sie höflich, dass Sie nur Termine analysieren.";
        
        // 2. User-Prompt: Die Textanfrage des Benutzers
        let userPrompt = "Extrahiere die folgenden Termindaten als JSON-Objekt. Verwende 'N/A', wenn Informationen fehlen. Meine Anfrage: ";
        if (imageFile) {
            userPrompt += "Analysiere das angehängte Bild und den Text und extrahiere die Termindaten.";
        } else {
             userPrompt += userText;
        }

        chatParts.push({ text: userPrompt });

        // 3. Bild-Teil (falls vorhanden)
        if (imageFile) {
            try {
                const base64Data = await fileToBase64(imageFile);
                chatParts.push({
                    inlineData: {
                        mimeType: imageFile.type,
                        data: base64Data
                    }
                });
            } catch (e) {
                console.error("Fehler beim Konvertieren des Bildes:", e);
                return { text: "Ein Fehler ist beim Hochladen des Bildes aufgetreten.", type: 'error' };
            }
        }

        // 4. Konstruiere das Payload
        const payload = {
            contents: [{ parts: chatParts }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: RESPONSE_SCHEMA
            },
        };

        const maxRetries = 3;
        let lastError = null;
        
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(API_URL + (GEMINI_API_KEY ? `?key=${GEMINI_API_KEY}` : ''), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429 || response.status >= 500) {
                    // Fehlerbehandlung: Rate Limit (429) oder Serverfehler (5xx)
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    console.warn(`Versuch ${attempt + 1} fehlgeschlagen (Status ${response.status}). Wiederhole in ${delay}ms.`);
                    lastError = `Gemini Serverfehler oder Rate Limit (Status ${response.status}).`;
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; 
                    }
                } else if (!response.ok) {
                    // Fehlerbehandlung: 400, 401, 403 etc.
                    const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));
                    const errorMessage = errorData.error ? errorData.error.message : response.statusText;
                    lastError = `**API-Fehler (${response.status})** - ${errorMessage}. Bitte überprüfen Sie in der Google Cloud Console, ob der API-Schlüssel gültig ist und die Generative Language API aktiviert ist.`;
                } else {
                    // Erfolg
                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!jsonText) {
                        lastError = "Die API gab eine leere oder ungültige JSON-Antwort zurück.";
                        continue;
                    }

                    // Der Modus 'application/json' gibt oft nur den JSON-String zurück,
                    // den wir parsen müssen.
                    const parsedJson = JSON.parse(jsonText);
                    
                    // Überprüfe, ob die JSON-Struktur ein erwartetes Feld enthält (z.B. 'datum')
                    if (parsedJson && parsedJson.hasOwnProperty('datum')) {
                        // Erfolgreiche Extraktion des Termins
                        return { 
                            text: "Ich habe die Termininformationen erfolgreich extrahiert. Hier ist das strukturierte Ergebnis:", 
                            structuredResponse: parsedJson, 
                            type: 'success' 
                        };
                    } else {
                        // Wenn der Benutzer keinen Termin genannt hat, bekommt er eine Textantwort.
                        // Hier versuchen wir, eine eventuelle Textantwort aus der JSON-Struktur zu holen,
                        // oder wir antworten mit einem Standardtext.
                        const textResponse = parsedJson.text || "Ich bin darauf spezialisiert, Termine zu extrahieren. Bitte geben Sie mir einen Text oder ein Bild mit Termininformationen.";
                        return { text: textResponse, type: 'text' };
                    }
                }

            } catch (error) {
                console.error("Netzwerkfehler oder allgemeiner Fehler:", error);
                lastError = `Ein Netzwerkfehler ist aufgetreten: ${error.message}`;
            }
        }
        
        // Nach allen Fehlversuchen:
        return { text: lastError || "Unbekannter Fehler nach allen Versuchen.", type: 'error' };
    }

    // --- Haupt-Sende-Funktion ---

    async function sendMessage() {
        const text = userInput.value.trim();
        const imageFile = currentImageFile;

        // Validierung, obwohl der Button deaktiviert sein sollte
        if (!text && !imageFile) return;

        // Temporäre URL für das hochgeladene Bild für die Anzeige
        const userImageUrl = imageFile ? URL.createObjectURL(imageFile) : null;
        
        // 1. Fügen Sie die Benutzer-Nachricht zur Historie hinzu
        addMessageToChat(text, 'user', userImageUrl); 
        
        // 2. Bild-Vorschau zurücksetzen und Eingabe leeren
        userInput.value = '';
        resetImageUpload();
        toggleSendButton(); // Sende-Button deaktivieren

        // 3. Ladeanzeige anzeigen
        showLoading();

        // 4. Gemini API aufrufen
        const response = await getGeminiResponse(text, imageFile);

        // 5. Ladeanzeige verstecken
        hideLoading();

        // 6. Gemini-Antwort zur Historie hinzufügen
        if (response.type === 'error') {
            // Zeige die Fehlermeldung als normalen Text an
            addMessageToChat(response.text, 'model'); 
        } else {
            // Zeige entweder die Textantwort oder die strukturierte Antwort an
            addMessageToChat(
                response.text, 
                'model', 
                null, 
                response.structuredResponse // Übergibt das JSON-Objekt zur strukturierten Darstellung
            );
        }

        // 7. Stellen Sie sicher, dass das Fenster nach der Antwort gescrollt wird
        scrollToBottom();
    }
    
    // --- Export-Funktion (Korrekt repariert) ---

    function downloadChat() {
        const chatContent = chatHistory.map(msg => {
            let content = msg.text.replace(/\*\*/g, '').replace(/\*/g, '').replace(/\n/g, '<br>'); // Markdowns entfernen für HTML-Export
            if (msg.structuredResponse) {
                content += '<div style="margin-top:10px; padding:10px; border:1px solid #ccc; border-radius:8px; background-color:#f0f4ff;"><strong>Gefundene Termindaten:</strong>';
                for (const key in msg.structuredResponse) {
                    const formattedKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                    content += `<br><span>${formattedKey}:</span> <span>${msg.structuredResponse[key] || 'N/A'}</span>`;
                }
                content += '</div>';
            }
            if (msg.imageUrl) {
                 content = `<img src="${msg.imageUrl}" style="max-width: 100%; height: auto; border-radius: 8px; margin-bottom: 10px;">${content}`;
            }
            
            const alignment = msg.sender === 'user' ? 'right' : 'left';
            const bgColor = msg.sender === 'user' ? '#DCF8C6' : '#E5E7EB';
            
            return `<div style="text-align: ${alignment}; margin-bottom: 15px;">
                        <div style="display: inline-block; max-width: 70%; padding: 10px 15px; border-radius: 20px; background-color: ${bgColor}; text-align: ${alignment === 'right' ? 'right' : 'left'}; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            ${content}
                        </div>
                    </div>`;
        }).join('');

        const fullHtml = `<!DOCTYPE html>
            <html lang="de">
            <head>
                <meta charset="UTF-8">
                <title>Chat Export - AI Termin-Detektiv</title>
                <style>
                    body { font-family: Arial, sans-serif; background-color: #f7ff; padding: 20px; }
                    /* Weitere Styles wie im JS oben */
                </style>
            </head>
            <body>
                <h1 style="color: #4B5563; border-bottom: 2px solid #ccc; padding-bottom: 10px;">AI Termin-Detektiv Chat Export</h1>
                <div style="max-width: 800px; margin: 0 auto; padding-top: 20px;">
                    ${chatContent}
                </div>
                <div style="text-align: center; margin-top: 30px; font-size: 0.8em; color: #999;">Exportiert am ${new Date().toLocaleString()}</div>
            </body>
            </html>
        `; 
        
        // *** HIER WAR DER FEHLER (zusätzliches Backtick) ***
        const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `chat_export_${new Date().toISOString().slice(0, 10)}.html`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // --- Initialisierung ---

    function initializeChat() {
        if (chatHistory.length === 0) {
            let welcomeMessage = "Willkommen beim **AI Termin-Detektiv**! Ich bin bereit, Ihre Termin-Infos zu analysieren. Senden Sie mir einfach **Text, einen Screenshot** oder ein **Foto** (z.B. von einem Brief oder einer Kalendereintragung).";
            addMessageToChat(welcomeMessage, 'model');
        } else {
            // Die setupChatListener Funktion kümmert sich um das Laden und Rendern,
            // daher brauchen wir hier nur sicherstellen, dass die History korrekt ist.
            // Die renderChatHistory wird nach onSnapshot ausgeführt.
        }
        toggleSendButton();
    }

    // --- Event Listener ---
    
    // Senden bei Enter-Taste, aber Zeilenumbruch bei Shift+Enter
    userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
        // Passt die Höhe des Textfelds dynamisch an
        userInput.style.height = 'auto';
        userInput.style.height = userInput.scrollHeight + 'px';
    });
    
    // Check, ob der Sende-Button aktiviert werden soll, wenn sich der Text ändert
    userInput.addEventListener('input', toggleSendButton);

    // Bild-Upload verarbeiten
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            currentImageFile = file;
            document.getElementById('image-preview').src = URL.createObjectURL(file);
            document.getElementById('image-filename').textContent = file.name;
            imagePreviewContainer.classList.remove('hidden');
            toggleSendButton(); // Sende-Button aktivieren
        } else {
            resetImageUpload();
            toggleSendButton(); // Sende-Button deaktivieren
        }
    });

    // Bild-Upload abbrechen
    document.getElementById('cancel-upload').addEventListener('click', () => {
        resetImageUpload();
        toggleSendButton();
    });

    // Chat initialisieren, sobald das DOM geladen ist
    window.onload = initializeFirebase; // Startet Firebase, das dann initializeChat aufruft

    </script>
</body>
</html>
