<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Termin-Generator (Mit automatischer Schlüssel-Verwaltung)</title>
    
    <!-- Lade Tailwind CSS für modernes Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* Custom Styles */
        .chat-container { height: 90vh; }
        .chat-window { scroll-behavior: smooth; }
        .message-row { display: flex; margin-bottom: 0.75rem; }
        .user-message-row { justify-content: flex-end; }
        .bot-message-row { justify-content: flex-start; }
        .message { padding: 0.75rem 1rem; border-radius: 1.5rem; max-width: 80%; line-height: 1.4; word-wrap: break-word; font-size: 0.95rem; } 
        .user-message { 
            background-color: #DCF8C6; 
            margin-left: auto; 
            border-bottom-right-radius: 4px;
        }
        .bot-message { 
            background-color: white; 
            border: 1px solid #E5E7EB; 
            border-bottom-left-radius: 4px; 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
        }
        .message img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 5px; cursor: pointer; }

        /* Loading Dots Animation */
        .loading-dot { display: inline-block; width: 8px; height: 8px; background-color: #10B981; border-radius: 50%; margin: 0 2px; animation: dot-pulse 1s infinite; }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes dot-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(0.8); opacity: 0.5; }
        }
        
        /* Button Styling */
        .action-button, .correction-button { 
            transition: all 0.2s; 
            font-weight: 500;
        }
        .correction-button {
            padding: 0.5rem 0.75rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.8rem;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #D1D5DB;
            background-color: #F9FAFB;
            color: #1F2937;
        }

        .correction-button:hover:not(:disabled) {
            background-color: #E5E7EB;
            border-color: #9CA3AF;
        }
        /* Textarea Höhe anpassen */
        #user-input {
            min-height: 40px; 
            max-height: 150px;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8 flex justify-center items-center min-h-screen">

<div class="chat-container w-full max-w-2xl bg-white shadow-2xl rounded-xl flex flex-col overflow-hidden">
    
    <header class="chat-header bg-indigo-600 text-white p-4 flex justify-between items-center rounded-t-xl">
        <h1 class="text-xl font-bold flex items-center">
            <span class="material-icons mr-2">smart_toy</span> AI Termin-Detektiv
        </h1>
        <div class="action-buttons flex space-x-2">
            <!-- Schlüssel-Icon entfernt, da der Schlüssel nun automatisch verwaltet wird -->
            <button onclick="downloadChat()" title="Chat als HTML herunterladen" class="p-1 rounded-full hover:bg-indigo-700 transition">
                <span class="material-icons">cloud_download</span>
            </button>
            <button onclick="deleteChatConfirmation()" title="Chatverlauf löschen (lokal)" class="p-1 rounded-full hover:bg-indigo-700 transition">
                <span class="material-icons">delete_forever</span>
            </button>
        </div>
    </header>
    
    <div class="chat-window flex-grow p-4 overflow-y-auto bg-gray-50" id="chat-window">
        <!-- Willkommensnachricht wird von JavaScript eingefügt -->
    </div>
    
    <!-- Bild-Vorschau-Bereich -->
    <div id="image-preview-container" class="hidden p-3 border-t border-gray-200 bg-white flex items-center">
        <img id="image-preview" src="#" alt="Vorschau des hochgeladenen Bildes" class="max-h-12 w-auto rounded mr-3">
        <span id="image-filename" class="text-sm text-gray-600 truncate"></span>
        <span id="cancel-upload" class="material-icons text-red-500 ml-auto cursor-pointer" title="Bild entfernen">close</span>
    </div>
    
    <!-- Eingabebereich -->
    <div class="chat-input flex p-4 border-t border-gray-200 bg-gray-50">
        <div class="file-upload-wrapper relative mr-2">
            <input type="file" id="file-input" accept="image/*" class="absolute inset-0 opacity-0 w-full h-full cursor-pointer">
            <button type="button" class="bg-blue-500 text-white p-2 rounded-full shadow-md hover:bg-blue-600 transition" title="Bild hochladen">
                <span class="material-icons">image</span>
            </button>
        </div>
        <textarea id="user-input" placeholder="Termininformationen eingeben..." 
                  class="flex-grow p-3 border border-gray-300 rounded-2xl resize-none mr-2 transition-all focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
        <button onclick="sendMessage()" id="send-button"
                class="bg-indigo-500 text-white w-10 h-10 rounded-full shadow-md hover:bg-indigo-600 transition flex items-center justify-center disabled:opacity-50" disabled>
            <span class="material-icons">send</span>
        </button>
    </div>
</div>

<script>
    // ******************************************************
    // *** 1. GEMINI KONFIGURATION & STATE ******************
    // ******************************************************
    
    const CHAT_STORAGE_KEY = "canvas_termin_hardcoded_history";
    const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025"; 

    // API Key wird als leere Zeichenkette definiert, um die automatische
    // Schlüssel-Verwaltung der Canvas-Plattform zu nutzen und den 403-Fehler zu vermeiden.
    const GEMINI_API_KEY = "";

    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const fileInput = document.getElementById('file-input');
    const sendButton = document.getElementById('send-button');
    const imagePreviewContainer = document.getElementById('image-preview-container');
    
    let currentImageFile = null;
    let chatHistory = []; 

    // ******************************************************
    // *** 2. UTILITIES & HELPER-FUNKTIONEN *****************
    // ******************************************************

    function toggleSendButton() {
        const text = userInput.value.trim();
        // Anpassung der Höhe des Textfelds bei Eingabe
        userInput.style.height = 'auto';
        userInput.style.height = Math.min(userInput.scrollHeight, 150) + 'px'; // Max 150px
        
        // Deaktiviere Senden, wenn kein Text/Bild vorhanden ist
        sendButton.disabled = (!text && !currentImageFile);
    }

    function getCurrentDateContext() {
        const now = new Date();
        const dateString = now.toISOString().slice(0, 10); // YYYY-MM-DD
        const dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
        const dayOfWeek = dayNames[now.getDay()];
        const timeString = now.toTimeString().slice(0, 5); 
        return `Aktuelles Datum (Heute): ${dateString} (${dayOfWeek}, ${timeString} Uhr).`;
    }

    async function fileToGenerativePart(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                const base64Data = reader.result.split(',')[1];
                resolve({
                    inlineData: {
                        data: base64Data,
                        mimeType: file.type,
                    },
                });
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // Konvertiert Datum/Zeit in das Google Calendar URL-Format
    function formatDateToGoogleCalendar(dateStr, timeStr, offsetMinutes = 60) {
        if (!dateStr || !timeStr) return null;
        
        const [year, month, day] = dateStr.split('-');
        const [hour, minute] = timeStr.split(':');
        
        // Startzeitpunkt (lokal)
        const startTimeLocal = new Date(year, month - 1, day, hour, minute); 
        
        // Endzeitpunkt: Startzeit + offsetMinutes
        const endTimeLocal = new Date(startTimeLocal);
        endTimeLocal.setMinutes(startTimeLocal.getMinutes() + offsetMinutes);
        
        const toGoogleFormat = (d) => {
            const pad = (num) => num.toString().padStart(2, '0');
            return d.getFullYear() +
                   pad(d.getMonth() + 1) +
                   pad(d.getDate()) + 'T' +
                   pad(d.getHours()) +
                   pad(d.getMinutes()) +
                   '00';
        };

        const startFormat = toGoogleFormat(startTimeLocal);
        const endFormat = toGoogleFormat(endTimeLocal);

        // Google Calendar erwartet UTC Zeitstempel ohne Z, aber da wir keinen Zeitzonen-Kontext haben, senden wir es als lokale Zeit.
        // Das T ist entscheidend.
        return `${startFormat}/${endFormat}`; 
    }

    function generateGoogleCalendarUrl(appointment) {
        const { date, time, purpose, location } = appointment;
        
        // Standardmäßig 60 Minuten Dauer annehmen
        const datesParam = formatDateToGoogleCalendar(date, time, 60); 
        
        if (!datesParam) return null;

        let url = 'https://calendar.google.com/calendar/render?action=TEMPLATE';
        url += '&text=' + encodeURIComponent(purpose || 'Termin');
        url += '&dates=' + datesParam;
        
        if (location) {
             url += '&location=' + encodeURIComponent(location);
        }

        url += '&details=' + encodeURIComponent(`Termin-Details:\n${purpose}\nOrt: ${location || 'Unbekannt'}`);
        
        return url;
    }
    
    // Generiert eine einfache ICS-Datei für andere Kalender-Apps
    function generateICS(appointment) {
        const { date, time, purpose, location } = appointment;
        const now = new Date();
        const uid = Date.now().toString() + "@generator"; // Einfache UID
        
        // ICS Zeitformat: YYYYMMDDTHHMMSS
        const toICSDateTime = (d, t, offsetMinutes = 60) => {
            if (!d || !t) return null;
            const [year, month, day] = d.split('-');
            const [hour, minute] = t.split(':');
            
            const startDate = new Date(year, month - 1, day, hour, minute);
            const endDate = new Date(startDate);
            endDate.setMinutes(startDate.getMinutes() + offsetMinutes);

            const pad = (num) => num.toString().padStart(2, '0');
            return {
                start: startDate.getFullYear() + pad(startDate.getMonth() + 1) + pad(startDate.getDate()) + 'T' + pad(startDate.getHours()) + pad(startDate.getMinutes()) + '00',
                end: endDate.getFullYear() + pad(endDate.getMonth() + 1) + pad(endDate.getDate()) + 'T' + pad(endDate.getHours()) + pad(endDate.getMinutes()) + '00'
            };
        };

        const icsDates = toICSDateTime(date, time, 60); // 60 Minuten Dauer
        if (!icsDates) return null;

        const icsContent = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'PRODID:-//AI Appointment Generator//DE',
            'BEGIN:VEVENT',
            `UID:${uid}`,
            'DTSTAMP:' + toICSDateTime(now.toISOString().slice(0, 10), now.toTimeString().slice(0, 5)).start + 'Z',
            `DTSTART:${icsDates.start}`,
            `DTEND:${icsDates.end}`,
            `SUMMARY:${purpose}`,
            location ? `LOCATION:${location}` : '',
            `DESCRIPTION:Extrahierter Termin: ${purpose} (Ort: ${location || 'Unbekannt'})`,
            'END:VEVENT',
            'END:VCALENDAR'
        ].filter(line => line).join('\n');

        return icsContent;
    }


    // ******************************************************
    // *** 3. GEMINI API & JSON HANDHABUNG ******************
    // ******************************************************

    function extractStructuredResponse(responseText) {
        // Sucht nach dem Muster ```json{...}```
        const match = responseText.match(/```json\s*([\s\S]*?)\s*```/m); 
        
        if (match && match[1]) {
            try {
                let jsonString = match[1].trim(); 
                
                // Ersetzen von häufigen Fehlern des Modells im JSON-String (z.B. doppelte Anführungszeichen)
                jsonString = jsonString
                    .replace(/\" oder \"\"/g, '""')
                    .replace(/oder \"\"/g, '""');

                const structuredResponse = JSON.parse(jsonString);
                
                // Grundlegende Validierung der Struktur
                if (structuredResponse.status && structuredResponse.primaryAppointment) {
                    const pa = structuredResponse.primaryAppointment;
                    // Stelle sicher, dass die Felder existieren, selbst wenn sie leer sind
                    pa.date = pa.date || "";
                    pa.time = pa.time || "";
                    pa.purpose = pa.purpose || "Termin ohne Details";
                    pa.location = pa.location || ""; 
                    
                    // Beschränke Vorschläge auf maximal 5
                    structuredResponse.suggestions = Array.isArray(structuredResponse.suggestions) ? structuredResponse.suggestions.slice(0, 5) : [];
                    
                    return structuredResponse;
                }
                
            } catch (e) {
                console.error("FEHLER: JSON-Parsing fehlgeschlagen. Details:", e, "Block:", match[1]);
            }
        }
        // console.error("FEHLER: JSON-Block (```json{...}```) nicht in der KI-Antwort gefunden.");
        return null; // Gibt null zurück, wenn kein gültiges JSON gefunden wird
    }

    async function getGeminiResponse(text, imageFile) {
        
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        
        let contents = [];
        const dateContext = getCurrentDateContext();

        // Füge den Chatverlauf hinzu (historische Konversation)
        chatHistory.forEach(msg => {
            const role = msg.sender === 'model' ? 'model' : 'user'; 
            let textToSend = msg.text;
            
            // Entferne den JSON-Block aus früheren Modellantworten, um das Prompt-Limit nicht zu überschreiten
            if (role === 'model') {
                const jsonMatch = msg.text.match(/```json\s*(\{[\s\S]*?\})\s*```/m);
                if (jsonMatch) {
                    textToSend = msg.text.replace(jsonMatch[0], '').trim();
                }
            }
            if (textToSend) {
                contents.push({ role: role, parts: [{ text: textToSend }] });
            }
        });

        const systemInstruction = {
            parts: [{
                text: `Du bist ein hochspezialisierter, freundlicher Termin-Detektiv. Deine Aufgabe ist es, aus dem gegebenen Text und/oder Bild die folgenden Informationen für einen Termin zu extrahieren: Datum (YYYY-MM-DD), Uhrzeit (HH:MM), den Zweck/Betreff (purpose) und den Ort (location).

                **WICHTIGER KONTEXT ZUR DATUMSBESTIMMUNG:**
                ${dateContext}
                Nutze diesen Kontext, um relative Datumsangaben ("nächsten Montag", "morgen") **korrekt und exakt** in das Format YYYY-MM-DD umzuwandeln.

                **Antwort-Regeln (EXTREM STRIKT EINHALTEN):**
                1. Die Antwort MUSS IMMER mit einem kurzen, einleitenden/erklärenden Satz beginnen (Feld "comment").
                2. UNMITTELBAR, in der **nächsten Zeile** nach diesem Satz, MUSS der JSON-Code-Block folgen. Dieser Block MUSS mit \`\`\`json beginnen und mit \`\`\` enden.
                3. **JSON-STATUS:** Setze "status" auf "ok", wenn Datum, Zeit und Zweck klar sind. Setze ihn auf **"needs_clarification"** wenn Datum, Zeit oder Zweck **unklar oder mehrdeutig** sind (z.B. "nächsten Freitag").
                
                **ZUSÄTZLICHE REGEL (TIPPFEHLER):** Wenn Sie einen wahrscheinlichen Tippfehler bei einem Namen, einer Entität oder einem Ort feststellen (z.B. 'Doktor Werbere' statt 'Doktor Weber' oder 'Berlinr' statt 'Berlin'), setzen Sie den Status auf **"needs_clarification"** und bieten Sie entsprechende Korrekturvorschläge im 'suggestions'-Array an. Nutzen Sie hierfür den Typ 'purpose_fix' (für Namen/Zweck) oder 'location_fix' (für Orte).

                4. **FEHLENDE DATEN:** Setze fehlende Daten (date, time, purpose, location) auf die **leere Zeichenkette ("")**.
                5. **VORSCHLÄGE:** Wenn der Status "needs_clarification" ist, fülle das **"suggestions"**-Array mit 3 bis 5 präzisen Text-Vorschlägen zur Korrektur oder Klärung, sowie einem "Manuelle Eingabe"-Button.

                **ERFORDERLICHES JSON-FORMAT (MUSS UNMITTELBAR NACH DEM EINLEITUNGSSATZ KOMMEN):**
                \`\`\`json
                {
                  "status": "ok" | "needs_clarification",
                  "comment": "Ein kurzer einleitender/erklärender Satz.",
                  "primaryAppointment": {
                    "date": "YYYY-MM-DD" | "",
                    "time": "HH:MM" | "",
                    "purpose": "Beschreibung des Termins/Betreff",
                    "location": "Ort des Termins (Adresse/Online-Link)" | ""
                  },
                  "suggestions": [
                    { "type": "date_fix" | "time_fix" | "purpose_fix" | "location_fix" | "manual", "text": "Korrekturvorschlag oder 'Manuelle Eingabe'" }
                  ]
                }
                \`\`\`
                6. Verwende immer die Sprache Deutsch.
                `
            }]
        };
        
        // Füge die aktuelle Nutzereingabe (Text und/oder Bild) hinzu
        let userParts = [];
        if (imageFile) {
            userParts.push(await fileToGenerativePart(imageFile));
        }
        if (text) {
            userParts.push({ text: text });
        } 
        
        contents.push({ role: "user", parts: userParts });

        const payload = {
            contents: contents,
            systemInstruction: systemInstruction,
            tools: [{ "google_search": {} }] 
        };

        let responseData = null;
        const maxRetries = 3;
        const baseDelay = 1000;

        // Exponential Backoff für Fehlertoleranz bei API-Aufrufen
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (response.status === 429 || response.status >= 500) {
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, attempt)));
                        continue;
                    }
                } else if (!response.ok) {
                    // Erneutes Fehler-Logging, falls der 403-Fehler (o.ä.) auftritt
                    const errorData = await response.json();
                    return `Fehler beim Senden an Gemini. Status: ${response.status}. Details: ${errorData.error.message}`;
                }

                responseData = await response.json();
                break;
            } catch (error) {
                if (attempt < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, attempt)));
                } else {
                    return "Ein Netzwerkfehler ist aufgetreten. Kann Gemini nicht erreichen.";
                }
            }
        }
        
        const candidateParts = responseData?.candidates?.[0]?.content?.parts;
        let fullResponseText = "";

        if (candidateParts) {
            for (const part of candidateParts) {
                if (part.text) {
                    fullResponseText += part.text;
                }
            }
        }

        if (fullResponseText) {
            return fullResponseText;
        } else {
            console.error("Gemini Response Strukturfehler. Details:", JSON.stringify(responseData));
            return "Es konnte keine gültige Text-Antwort von der KI empfangen werden. (Strukturfehler)";
        }
    }


    // ******************************************************
    // *** 4. CHAT DISPLAY & RENDERING **********************
    // ******************************************************
    
    function handleCorrection(type, text) {
        let correctionPrompt;
        
        if (type === 'manual') {
            // Bei manueller Eingabe wird der ursprüngliche Text im Eingabefeld platziert
            correctionPrompt = chatHistory[chatHistory.length - 2].text; 
            userInput.value = correctionPrompt;
            userInput.focus();
            toggleSendButton();
        } else {
            // Bei Korrekturvorschlag wird ein neuer Prompt an die KI gesendet
            correctionPrompt = `Bitte verwende diesen Vorschlag zur Korrektur des letzten Termins: ${text}`;
            userInput.value = correctionPrompt; 
            sendMessage(); 
        }
    }

    function createMessageElement(messageContent, sender, imageUrl, structuredResponse) {
        const row = document.createElement('div');
        row.classList.add('message-row', sender === 'user' ? 'user-message-row' : 'bot-message-row');

        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message', 'shadow-sm');

        if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = sender === 'user' ? 'Hochgeladenes Bild' : 'Bild';
            img.classList.add('mb-2');
            msgDiv.appendChild(img);
        }

        let htmlContent = messageContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1').replace(/\n/g, '<br>').trim();
        const jsonMatch = htmlContent.match(/```json\s*(\{[\s\S]*?\})\s*```/m);
        let cleanedHtmlContent = htmlContent;
        let appointment = null;

        // 1. JSON-Block aus dem Text entfernen
        if (jsonMatch) {
            cleanedHtmlContent = htmlContent.replace(jsonMatch[0], '').trim();
        }
        
        // Der Kommentar ist entweder der extrahierte Kommentar oder der gesamte KI-Text, wenn kein JSON gefunden wurde
        const comment = structuredResponse?.comment || cleanedHtmlContent.split('<br>')[0].trim();
        const textNode = document.createElement('p');
        textNode.innerHTML = comment;
        msgDiv.appendChild(textNode);
        
        // 2. Termin-Zusammenfassung und Buttons erstellen
        if (structuredResponse && structuredResponse.primaryAppointment) {
            appointment = structuredResponse.primaryAppointment;
            const isClarificationNeeded = structuredResponse.status === 'needs_clarification';
            const hasDateTime = appointment.date && appointment.time;
            
            const dateDisplay = appointment.date || '<span class="text-red-500 font-medium">Datum fehlt</span>';
            const timeDisplay = appointment.time || '<span class="text-red-500 font-medium">Zeit fehlt</span>';
            const purposeDisplay = appointment.purpose || '<span class="text-red-500 font-medium">Zweck fehlt</span>';
            const locationDisplay = appointment.location || '<span class="text-gray-400">Ort fehlt/optional</span>';
            
            const uiHtml = `
                <div class="appointment-summary ${isClarificationNeeded ? 'bg-yellow-50 text-yellow-800 border-yellow-200' : 'bg-green-50 text-green-800 border-green-200'} p-3 mt-3 mb-2 rounded-lg border">
                    <p class="font-bold mb-1 border-b pb-1 ${isClarificationNeeded ? 'border-yellow-200' : 'border-green-200'}">
                        ${isClarificationNeeded ? '⚠️ Korrektur nötig' : '✅ Termin extrahiert'}
                    </p>
                    <ul class="list-none text-sm space-y-1 mt-2">
                        <li><span class="font-semibold w-20 inline-block">Zweck:</span> ${purposeDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Datum:</span> ${dateDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Uhrzeit:</span> ${timeDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Ort:</span> ${locationDisplay}</li>
                    </ul>
                </div>
            `;
            msgDiv.innerHTML += uiHtml;
            
            // 3. Korrektur-Buttons hinzufügen
            if (isClarificationNeeded && structuredResponse.suggestions.length > 0) {
                const correctionButtonsContainer = document.createElement('div');
                correctionButtonsContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mt-3', 'p-2', 'bg-gray-100', 'rounded-lg', 'border', 'border-gray-200');
                
                structuredResponse.suggestions.forEach(s => {
                    const btn = document.createElement('button');
                    btn.classList.add('correction-button');
                    
                    let icon = '';
                    switch (s.type) {
                        case 'date_fix': icon = 'calendar_today'; break;
                        case 'time_fix': icon = 'schedule'; break;
                        case 'purpose_fix': icon = 'label'; break;
                        case 'location_fix': icon = 'place'; break;
                        case 'manual': icon = 'keyboard'; btn.classList.add('bg-indigo-100', 'border-indigo-400', 'text-indigo-800'); break;
                        default: icon = 'help_outline';
                    }
                    
                    btn.innerHTML = `<span class="material-icons text-base mr-1">${icon}</span> ${s.text}`;
                    
                    // Bei Klick handleCorrection aufrufen
                    btn.onclick = () => handleCorrection(s.type, s.text === 'Manuelle Eingabe' ? messageContent : s.text);
                    correctionButtonsContainer.appendChild(btn);
                });
                msgDiv.appendChild(correctionButtonsContainer);
            }

            // 4. Kalender-Aktions-Buttons hinzufügen
            if (!isClarificationNeeded && hasDateTime) {
                const actionContainer = document.createElement('div');
                actionContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mt-3', 'pt-2', 'border-t', 'border-gray-200');
                
                // Google Calendar Link Button
                const gcalUrl = generateGoogleCalendarUrl(appointment);
                const gcalBtn = document.createElement('a');
                gcalBtn.href = gcalUrl;
                gcalBtn.target = '_blank';
                gcalBtn.classList.add('action-button', 'bg-blue-500', 'text-white', 'py-2', 'px-4', 'rounded-full', 'hover:bg-blue-600', 'transition', 'text-sm', 'flex', 'items-center');
                gcalBtn.innerHTML = '<span class="material-icons text-lg mr-1">event</span> In Google Kalender';
                actionContainer.appendChild(gcalBtn);

                // ICS Download Button
                const icsBtn = document.createElement('button');
                icsBtn.classList.add('action-button', 'bg-gray-200', 'text-gray-800', 'py-2', 'px-4', 'rounded-full', 'hover:bg-gray-300', 'transition', 'text-sm', 'flex', 'items-center');
                icsBtn.innerHTML = '<span class="material-icons text-lg mr-1">file_download</span> ICS herunterladen';
                icsBtn.onclick = () => downloadICS(appointment);
                actionContainer.appendChild(icsBtn);

                // Text Kopieren Button
                const copyTextBtn = document.createElement('button');
                copyTextBtn.classList.add('action-button', 'bg-gray-200', 'text-gray-800', 'py-2', 'px-4', 'rounded-full', 'hover:bg-gray-300', 'transition', 'text-sm', 'flex', 'items-center');
                copyTextBtn.innerHTML = '<span class="material-icons text-lg mr-1">content_copy</span> Text kopieren';
                copyTextBtn.onclick = () => copyAppointmentText(appointment, copyTextBtn);
                actionContainer.appendChild(copyTextBtn);

                msgDiv.appendChild(actionContainer);
            }
        } else if (sender === 'model') {
            // Fehlermeldungen (z.B. API-Fehler)
            textNode.innerHTML = messageContent.replace(/\n/g, '<br>');
            textNode.classList.add('text-red-600', 'font-semibold');
        }


        row.appendChild(msgDiv);
        return row;
    }

    // Funktion zum Kopieren des Termin-Textes in die Zwischenablage
    function copyAppointmentText(appointment, button) {
        const textToCopy = `Termin-Zusammenfassung:\nZweck: ${appointment.purpose}\nDatum: ${appointment.date}\nUhrzeit: ${appointment.time}\nOrt: ${appointment.location || 'Unbekannt'}`;
        
        const originalText = button.innerHTML;
        const originalBg = button.classList.contains('bg-gray-200') ? 'bg-gray-200' : 'bg-green-500';
        
        try {
            // Empfohlene, aber manchmal im iframe blockierte Methode
            navigator.clipboard.writeText(textToCopy).then(() => {
                button.innerHTML = '<span class="material-icons text-lg mr-1">done</span> Kopiert!';
                button.classList.remove(originalBg, 'bg-gray-200');
                button.classList.add('bg-green-500', 'text-white');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('bg-green-500', 'text-white');
                    button.classList.add(originalBg);
                }, 2000);
            }).catch(() => {
                // Fallback für iframes
                fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg);
            });
        } catch (err) {
            fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg);
        }
    }

    function fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg) {
        const textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        textArea.style.position = "fixed"; 
        textArea.style.left = "-9999px"; 
        textArea.style.top = "-9999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                button.innerHTML = '<span class="material-icons text-lg mr-1">done</span> Kopiert!';
                button.classList.remove(originalBg, 'bg-gray-200');
                button.classList.add('bg-green-500', 'text-white');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('bg-green-500', 'text-white');
                    button.classList.add(originalBg);
                }, 2000);
            }
        } catch (err) {
            console.error('Kopieren fehlgeschlagen:', err);
        }
        document.body.removeChild(textArea);
    }

    // Funktion zum Herunterladen der ICS-Datei
    function downloadICS(appointment) {
        const icsContent = generateICS(appointment);
        if (!icsContent) return;

        const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        
        // Dateiname basierend auf Zweck und Datum
        const fileName = (appointment.purpose || 'Termin').replace(/\s/g, '_').substring(0, 30);
        link.download = `${fileName}_${appointment.date}.ics`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    function addMessageToChat(text, sender, imageUrl, structuredResponse = null) {
        const msgElement = createMessageElement(text, sender, imageUrl, structuredResponse);
        chatWindow.appendChild(msgElement);
        
        // Speichere die Nachricht, aber entferne den JSON-Block aus dem Chatverlauf, um Token zu sparen
        let textToStore = text;
        if (structuredResponse) {
            const jsonMatch = text.match(/```json\s*(\{[\s\S]*?\})\s*```/m);
            if (jsonMatch) {
                textToStore = text.replace(jsonMatch[0], '').trim();
            }
        }

        // Speichere nur den relevanten Text und die Metadaten
        chatHistory.push({
            sender: sender,
            text: textToStore,
            imageUrl: imageUrl || null
        });
        
        saveChatHistory();
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function showLoading() {
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'loading-indicator';
        loadingDiv.classList.add('message-row', 'bot-message-row');
        
        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', 'bot-message');
        msgDiv.innerHTML = `
            <div>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            </div>
        `;
        
        loadingDiv.appendChild(msgDiv);
        chatWindow.appendChild(loadingDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function hideLoading() {
        const loadingDiv = document.getElementById('loading-indicator');
        if (loadingDiv) {
            loadingDiv.remove();
        }
    }


    // ******************************************************
    // *** 5. HAUPT-LOGIK & EREIGNISSE **********************
    // ******************************************************

    async function sendMessage() {
        const text = userInput.value.trim();
        const imageFile = currentImageFile;

        if (!text && !imageFile) return;
        
        // 1. Nutzernachricht anzeigen und Eingabe leeren
        userInput.value = '';
        toggleSendButton();
        addMessageToChat(text, 'user', imageFile ? URL.createObjectURL(imageFile) : null);
        
        // 2. Bild-Vorschau zurücksetzen
        resetImageUpload();

        // 3. Ladeanzeige anzeigen
        showLoading();

        // 4. KI-Antwort abrufen
        const responseText = await getGeminiResponse(text, imageFile);
        
        // 5. Ladeanzeige ausblenden
        hideLoading();
        
        // 6. Antwort verarbeiten und anzeigen
        const structuredResponse = extractStructuredResponse(responseText);

        if (structuredResponse) {
            addMessageToChat(responseText, 'model', null, structuredResponse);
        } else {
            // Wenn JSON fehlt oder fehlerhaft ist, zeige den gesamten Text als einfache Nachricht
            addMessageToChat(responseText, 'model');
        }
    }
    
    function resetImageUpload() {
        currentImageFile = null;
        fileInput.value = '';
        imagePreviewContainer.classList.add('hidden');
    }

    // --- Chat-Verlauf Speichern/Laden/Löschen ---
    
    function saveChatHistory() {
        localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(chatHistory));
    }

    function loadChatHistory() {
        const savedHistory = localStorage.getItem(CHAT_STORAGE_KEY);
        if (savedHistory) {
            chatHistory = JSON.parse(savedHistory);
            chatHistory.forEach(msg => {
                const structured = msg.sender === 'model' ? extractStructuredResponse(msg.text) : null;
                addMessageToChat(msg.text, msg.sender, msg.imageUrl, structured);
            });
        }
    }

    function deleteChatConfirmation() {
        // Da wir kein confirm() verwenden dürfen, simulieren wir eine Bestätigungs-Modal
        const modal = document.createElement('div');
        modal.classList.add('fixed', 'inset-0', 'bg-gray-900', 'bg-opacity-75', 'flex', 'items-center', 'justify-center', 'z-50');
        modal.innerHTML = `
            <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
                <h3 class="text-xl font-bold mb-3 text-red-600">Chatverlauf löschen?</h3>
                <p class="mb-4 text-gray-700">Sind Sie sicher, dass Sie den gesamten Chatverlauf unwiderruflich löschen möchten?</p>
                <div class="flex justify-end space-x-3">
                    <button id="cancel-delete" class="bg-gray-200 text-gray-700 py-2 px-4 rounded-full hover:bg-gray-300 transition">Abbrechen</button>
                    <button id="confirm-delete" class="bg-red-500 text-white py-2 px-4 rounded-full hover:bg-red-600 transition">Ja, löschen</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);

        document.getElementById('cancel-delete').onclick = () => modal.remove();
        document.getElementById('confirm-delete').onclick = () => {
            modal.remove();
            localStorage.removeItem(CHAT_STORAGE_KEY);
            chatHistory = [];
            chatWindow.innerHTML = '';
            initializeChat(); // Starte den Chat neu mit der Willkommensnachricht
        };
    }
    
    function downloadChat() {
        const chatHtml = chatWindow.innerHTML;
        const fullHtml = `
            <!DOCTYPE html>
            <html lang="de">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Exportierter Chat - AI Termin-Detektiv</title>
                <script src="https://cdn.tailwindcss.com"></script>
                <style>
                    body { font-family: sans-serif; background-color: #f3f4f6; padding: 20px; }
                    .chat-window { max-width: 800px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
                    .message-row { display: flex; margin-bottom: 0.75rem; }
                    .user-message-row { justify-content: flex-end; }
                    .bot-message-row { justify-content: flex-start; }
                    .message { padding: 0.75rem 1rem; border-radius: 1.5rem; max-width: 80%; line-height: 1.4; word-wrap: break-word; font-size: 0.95rem; } 
                    .user-message { background-color: #DCF8C6; margin-left: auto; border-bottom-right-radius: 4px; }
                    .bot-message { background-color: #F9FAFB; border: 1px solid #E5E7EB; border-bottom-left-radius: 4px; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05); }
                    .appointment-summary { padding: 0.75rem; margin-top: 0.75rem; border-radius: 0.5rem; border: 1px solid; }
                    .bg-green-50 { background-color: #F0FDF4; }
                    .text-green-800 { color: #065F46; }
                    .border-green-200 { border-color: #A7F3D0; }
                    .bg-yellow-50 { background-color: #FFFBEB; }
                    .text-yellow-800 { color: #92400E; }
                    .border-yellow-200 { border-color: #FDE68A; }
                    .correction-button, .action-button { display: none; } /* Buttons im Export ausblenden */
                </style>
            </head>
            <body>
                <div class="chat-window">
                    <h1 class="text-2xl font-bold mb-4 text-indigo-600">Exportierter Chatverlauf</h1>
                    ${chatHtml}
                </div>
            </body>
            </html>
        `;
        const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `chat_export_${new Date().toISOString().slice(0, 10)}.html`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function initializeChat() {
        if (chatHistory.length === 0) {
            let welcomeMessage = "Willkommen beim **AI Termin-Detektiv**! Der API-Schlüssel wird jetzt automatisch und sicher verwaltet, um den 403-Fehler zu vermeiden. Ich bin bereit, Ihre Termin-Infos zu analysieren. Senden Sie mir einfach **Text, einen Screenshot** oder ein **Foto** (z.B. von einem Brief oder einer Kalendereintragung).";
            addMessageToChat(welcomeMessage, 'model');
        } else {
            loadChatHistory();
        }
        // Sende-Button muss nach der Initialisierung aktiviert werden, da der Schlüssel nun immer vorhanden ist
        toggleSendButton();
    }

    // --- Event Listener ---
    
    // Senden bei Enter-Taste, aber Zeilenumbruch bei Shift+Enter
    userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Check, ob der Sende-Button aktiviert werden soll, wenn sich der Text ändert
    userInput.addEventListener('input', toggleSendButton);

    // Bild-Upload verarbeiten
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            currentImageFile = file;
            document.getElementById('image-preview').src = URL.createObjectURL(file);
            document.getElementById('image-filename').textContent = file.name;
            imagePreviewContainer.classList.remove('hidden');
            toggleSendButton(); // Sende-Button aktivieren
        } else {
            resetImageUpload();
            toggleSendButton(); // Sende-Button deaktivieren
        }
    });

    // Bild-Upload abbrechen
    document.getElementById('cancel-upload').addEventListener('click', () => {
        resetImageUpload();
        toggleSendButton();
    });

    // Chat initialisieren, sobald das DOM geladen ist
    window.onload = initializeChat;

</script>
</body>
</html>
