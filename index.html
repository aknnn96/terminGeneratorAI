<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Termin-Generator (Robuste Version)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }

        /* Custom Styles */
        .chat-container { height: 90vh; min-height: 600px; } /* Feste Mindesthöhe hinzugefügt */
        .chat-window { scroll-behavior: smooth; }
        .message-row { display: flex; margin-bottom: 0.75rem; }
        .user-message-row { justify-content: flex-end; }
        .bot-message-row { justify-content: flex-start; }
        /* Max-Breite auf 85% erhöht für bessere Lesbarkeit auf Desktop */
        .message { padding: 0.75rem 1rem; border-radius: 1.5rem; max-width: 85%; line-height: 1.4; word-wrap: break-word; font-size: 0.95rem; } 
        .user-message { 
            background-color: #DCF8C6; 
            margin-left: auto; 
            border-bottom-right-radius: 4px;
        }
        .bot-message { 
            background-color: white; 
            border: 1px solid #E5E7EB; 
            border-bottom-left-radius: 4px; 
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
        }
        .message img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 5px; cursor: pointer; }

        /* Loading Dots Animation */
        .loading-dot { display: inline-block; width: 8px; height: 8px; background-color: #10B981; border-radius: 50%; margin: 0 2px; animation: dot-pulse 1s infinite; }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes dot-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(0.8); opacity: 0.5; }
        }
        
        /* Button Styling */
        .action-button, .correction-button { 
            transition: all 0.2s; 
            font-weight: 500;
        }
        .correction-button {
            padding: 0.5rem 0.75rem;
            border-radius: 9999px; /* Pill shape */
            font-size: 0.8rem;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #D1D5DB;
            background-color: #F9FAFB;
            color: #1F2937;
        }

        .correction-button:hover:not(:disabled) {
            background-color: #E5E7EB;
            border-color: #9CA3AF;
        }
        /* Textarea Höhe anpassen */
        #user-input {
            min-height: 40px; 
            max-height: 150px;
            /* Scrollbar nur anzeigen, wenn nötig */
            overflow-y: auto;
        }
        /* Container für Loading-Dots, um die Höhe des Bot-Messages zu erzwingen */
        .loading-content {
            display: flex;
            align-items: center;
            min-height: 1.5rem; /* Mindesthöhe für die Punkte */
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8 flex justify-center items-center min-h-screen">

<div class="chat-container w-full max-w-2xl bg-white shadow-2xl rounded-xl flex flex-col overflow-hidden">
    
    <header class="chat-header bg-indigo-600 text-white p-4 flex justify-between items-center rounded-t-xl">
        <h1 class="text-xl font-bold flex items-center">
            <span class="material-icons mr-2">smart_toy</span> AI Termin-Detektiv
        </h1>
        <div class="action-buttons flex space-x-2 items-center"> <button onclick="downloadChat()" title="Chat als HTML herunterladen" class="p-1 rounded-full hover:bg-indigo-700 transition">
                <span class="material-icons">cloud_download</span>
            </button>
            <button onclick="deleteChatConfirmation()" title="Chatverlauf löschen (lokal)" class="p-1 rounded-full hover:bg-indigo-700 transition">
                <span class="material-icons">delete_forever</span>
            </button>
        </div>
    </header>
    
    <div class="chat-window flex-grow p-4 overflow-y-auto bg-gray-50" id="chat-window">
        </div>
    
    <div id="image-preview-container" class="hidden p-3 border-t border-gray-200 bg-white flex items-center">
        <img id="image-preview" src="#" alt="Vorschau des hochgeladenen Bildes" class="max-h-12 w-auto rounded mr-3">
        <span id="image-filename" class="text-sm text-gray-600 truncate"></span>
        <span id="cancel-upload" class="material-icons text-red-500 ml-auto cursor-pointer" title="Bild entfernen">close</span>
    </div>
    
    <div class="chat-input flex p-4 border-t border-gray-200 bg-gray-50 items-end"> <div class="file-upload-wrapper relative mr-2">
            <input type="file" id="file-input" accept="image/*" class="absolute inset-0 opacity-0 w-full h-full cursor-pointer">
            <button type="button" class="bg-blue-500 text-white p-2 rounded-full shadow-md hover:bg-blue-600 transition" title="Bild hochladen">
                <span class="material-icons">image</span>
            </button>
        </div>
        <textarea id="user-input" placeholder="Termininformationen eingeben..." 
                  class="flex-grow p-3 border border-gray-300 rounded-2xl resize-none mr-2 transition-all focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"></textarea>
        <button onclick="sendMessage()" id="send-button"
                class="bg-indigo-500 text-white w-10 h-10 rounded-full shadow-md hover:bg-indigo-600 transition flex items-center justify-center disabled:opacity-50" disabled>
            <span class="material-icons">send</span>
        </button>
    </div>
</div>

<script>
    // ******************************************************
    // *** 1. GEMINI KONFIGURATION & STATE ******************
    // ******************************************************
    
    const CHAT_STORAGE_KEY = "canvas_termin_hardcoded_history_v2";
    const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025"; 

    // API Key wird als leere Zeichenkette definiert, um die automatische
    // Schlüssel-Verwaltung der Canvas-Plattform zu nutzen.
    const GEMINI_API_KEY = "AIzaSyD_DevrmddfF5bmXiQUbvbwQpS0HGEgfOY";

    const chatWindow = document.getElementById('chat-window');
    const userInput = document.getElementById('user-input');
    const fileInput = document.getElementById('file-input');
    const sendButton = document.getElementById('send-button');
    const imagePreviewContainer = document.getElementById('image-preview-container');
    
    let currentImageFile = null;
    let chatHistory = []; 

    // ******************************************************
    // *** 2. UTILITIES & HELPER-FUNKTIONEN *****************
    // ******************************************************

    function toggleSendButton() {
        const text = userInput.value.trim();
        // Anpassung der Höhe des Textfelds bei Eingabe
        userInput.style.height = 'auto';
        // Sicherstellen, dass die Höhe korrekt gesetzt wird
        const newHeight = Math.min(userInput.scrollHeight, 150);
        if (newHeight > 40) { // Nur anpassen, wenn es über der Mindesthöhe ist
            userInput.style.height = newHeight + 'px';
        } else {
            userInput.style.height = '40px'; // Oder was auch immer die min-height ist
        }
        
        // Deaktiviere Senden, wenn kein Text/Bild vorhanden ist
        sendButton.disabled = (!text && !currentImageFile);
    }

    function getCurrentDateContext() {
        const now = new Date();
        const dateString = now.toISOString().slice(0, 10); // YYYY-MM-DD
        const dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
        const dayOfWeek = dayNames[now.getDay()];
        const timeString = now.toTimeString().slice(0, 5); 
        return `Aktuelles Datum (Heute): ${dateString} (${dayOfWeek}, ${timeString} Uhr).`;
    }

    async function fileToGenerativePart(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                const base64Data = reader.result.split(',')[1];
                resolve({
                    inlineData: {
                        data: base64Data,
                        mimeType: file.type,
                    },
                });
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // Konvertiert Datum/Zeit in das Google Calendar URL-Format
    function formatDateToGoogleCalendar(dateStr, timeStr, offsetMinutes = 60) {
        if (!dateStr || !timeStr) return null;
        
        const [year, month, day] = dateStr.split('-');
        const [hour, minute] = timeStr.split(':');
        
        // Startzeitpunkt (lokal)
        const startTimeLocal = new Date(year, month - 1, day, hour, minute); 
        
        // Endzeitpunkt: Startzeit + offsetMinutes
        const endTimeLocal = new Date(startTimeLocal);
        endTimeLocal.setMinutes(startTimeLocal.getMinutes() + offsetMinutes);
        
        const toGoogleFormat = (d) => {
            const pad = (num) => num.toString().padStart(2, '0');
            return d.getFullYear() +
                   pad(d.getMonth() + 1) +
                   pad(d.getDate()) + 'T' +
                   pad(d.getHours()) +
                   pad(d.getMinutes()) +
                   '00';
        };

        const startFormat = toGoogleFormat(startTimeLocal);
        const endFormat = toGoogleFormat(endTimeLocal);

        // Google Calendar erwartet UTC Zeitstempel ohne Z, aber da wir keinen Zeitzonen-Kontext haben, senden wir es als lokale Zeit.
        return `${startFormat}/${endFormat}`; 
    }

    function generateGoogleCalendarUrl(appointment) {
        const { date, time, purpose, location } = appointment;
        
        // Standardmäßig 60 Minuten Dauer annehmen
        const datesParam = formatDateToGoogleCalendar(date, time, 60); 
        
        if (!datesParam) return null;

        let url = 'https://calendar.google.com/calendar/render?action=TEMPLATE';
        url += '&text=' + encodeURIComponent(purpose || 'Termin');
        url += '&dates=' + datesParam;
        
        if (location) {
             url += '&location=' + encodeURIComponent(location);
        }

        url += '&details=' + encodeURIComponent(`Termin-Details:\n${purpose}\nOrt: ${location || 'Unbekannt'}`);
        
        return url;
    }
    
    // Generiert eine einfache ICS-Datei für andere Kalender-Apps
    function generateICS(appointment) {
        const { date, time, purpose, location } = appointment;
        const now = new Date();
        const uid = Date.now().toString() + "@generator"; // Einfache UID
        
        // ICS Zeitformat: YYYYMMDDTHHMMSS
        const toICSDateTime = (d, t, offsetMinutes = 60) => {
            if (!d || !t) return null;
            const [year, month, day] = d.split('-');
            const [hour, minute] = t.split(':');
            
            const startDate = new Date(year, month - 1, day, hour, minute);
            const endDate = new Date(startDate);
            endDate.setMinutes(startDate.getMinutes() + offsetMinutes);

            const pad = (num) => num.toString().padStart(2, '0');
            return {
                start: startDate.getFullYear() + pad(startDate.getMonth() + 1) + pad(startDate.getDate()) + 'T' + pad(startDate.getHours()) + pad(startDate.getMinutes()) + '00',
                end: endDate.getFullYear() + pad(endDate.getMonth() + 1) + pad(endDate.getDate()) + 'T' + pad(endDate.getHours()) + pad(endDate.getMinutes()) + '00'
            };
        };

        const icsDates = toICSDateTime(date, time, 60); // 60 Minuten Dauer
        if (!icsDates) return null;

        const icsContent = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'PRODID:-//AI Appointment Generator//DE',
            'BEGIN:VEVENT',
            `UID:${uid}`,
            // DTSTAMP sollte in UTC sein, aber wir verwenden die lokale Zeit ohne Zoneninfo für Einfachheit
            `DTSTAMP:${toICSDateTime(now.toISOString().slice(0, 10), now.toTimeString().slice(0, 5)).start}`, 
            `DTSTART:${icsDates.start}`,
            `DTEND:${icsDates.end}`,
            `SUMMARY:${purpose}`,
            location ? `LOCATION:${location}` : '',
            `DESCRIPTION:Extrahierter Termin: ${purpose} (Ort: ${location || 'Unbekannt'})`,
            'END:VEVENT',
            'END:VCALENDAR'
        ].filter(line => line).join('\n');

        return icsContent;
    }


    // ******************************************************
    // *** 3. GEMINI API & JSON HANDHABUNG ******************
    // ******************************************************

    function extractStructuredResponse(responseText) {
        // Sucht nach dem Muster ```json{...}```
        const match = responseText.match(/```json\s*([\s\S]*?)\s*```/m); 
        
        if (match && match[1]) {
            try {
                let jsonString = match[1].trim(); 
                
                // Ersetzen von häufigen Fehlern des Modells im JSON-String 
                jsonString = jsonString
                    .replace(/\" oder \"\"/g, '""')
                    .replace(/oder \"\"/g, '""');

                const structuredResponse = JSON.parse(jsonString);
                
                // Grundlegende Validierung der Struktur
                if (structuredResponse.status && structuredResponse.primaryAppointment) {
                    const pa = structuredResponse.primaryAppointment;
                    // Stelle sicher, dass die Felder existieren
                    pa.date = pa.date || "";
                    pa.time = pa.time || "";
                    pa.purpose = pa.purpose || "Termin ohne Details";
                    pa.location = pa.location || ""; 
                    
                    // Beschränke Vorschläge auf maximal 5
                    structuredResponse.suggestions = Array.isArray(structuredResponse.suggestions) ? structuredResponse.suggestions.slice(0, 5) : [];
                    
                    // Speichere den Kommentar separat, da der Text manchmal den JSON-Block enthält
                    structuredResponse.comment = structuredResponse.comment || responseText.split(match[0])[0].trim();
                    
                    return structuredResponse;
                }
                
            } catch (e) {
                console.error("FEHLER: JSON-Parsing fehlgeschlagen. Details:", e, "Block:", match[1]);
            }
        }
        return null; // Gibt null zurück, wenn kein gültiges JSON gefunden wird
    }

    async function getGeminiResponse(text, imageFile) {
        
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
        
        let contents = [];
        const dateContext = getCurrentDateContext();

        // Füge den Chatverlauf hinzu (historische Konversation)
        chatHistory.forEach(msg => {
            const role = msg.sender === 'model' ? 'model' : 'user'; 
            let textToSend = msg.text;
            
            // Bereinige den Text, falls es sich um eine frühere KI-Antwort handelt, die JSON enthielt
            // Wichtig: Wir senden nur den relevanten Text zurück, um das Prompt-Limit zu schonen
            if (role === 'model') {
                 // Entferne den JSON-Block aus früheren Modellantworten
                const jsonMatch = msg.text.match(/```json\s*(\{[\s\S]*?\})\s*```/m);
                if (jsonMatch) {
                    // Verwende den gespeicherten Kommentar, falls vorhanden, sonst den Text vor dem JSON
                    textToSend = msg.structuredResponse?.comment || msg.text.split(jsonMatch[0])[0].trim() || "Termin-Detektiv Antwort";
                }
            }

            if (textToSend) {
                let parts = [{ text: textToSend }];
                // Hinzufügen von Bild-Metadaten zur History ist komplex und wird weggelassen,
                // um die Komplexität und die Token-Limits zu reduzieren.
                contents.push({ role: role, parts: parts });
            }
        });

        const systemInstruction = {
            parts: [{
                text: `Du bist ein hochspezialisierter, freundlicher Termin-Detektiv. Deine Aufgabe ist es, aus dem gegebenen Text und/oder Bild die folgenden Informationen für einen Termin zu extrahieren: Datum (YYYY-MM-DD), Uhrzeit (HH:MM), den Zweck/Betreff (purpose) und den Ort (location).

                **WICHTIGER KONTEXT ZUR DATUMSBESTIMMUNG:**
                ${dateContext}
                Nutze diesen Kontext, um relative Datumsangaben ("nächsten Montag", "morgen") **korrekt und exakt** in das Format YYYY-MM-DD umzuwandeln.

                **Antwort-Regeln (EXTREM STRIKT EINHALTEN):**
                1. Die Antwort MUSS IMMER mit einem kurzen, einleitenden/erklärenden Satz beginnen (Feld "comment").
                2. UNMITTELBAR, in der **nächsten Zeile** nach diesem Satz, MUSS der JSON-Code-Block folgen. Dieser Block MUSS mit \`\`\`json beginnen und mit \`\`\` enden.
                3. **JSON-STATUS:** Setze "status" auf "ok", wenn Datum, Zeit und Zweck klar sind. Setze ihn auf **"needs_clarification"** wenn Datum, Zeit oder Zweck **unklar oder mehrdeutig** sind (z.B. "nächsten Freitag").
                
                **ZUSÄTZLICHE REGEL (TIPPFEHLER):** Wenn Sie einen wahrscheinlichen Tippfehler bei einem Namen, einer Entität oder einem Ort feststellen, setzen Sie den Status auf **"needs_clarification"** und bieten Sie entsprechende Korrekturvorschläge im 'suggestions'-Array an. Nutzen Sie hierfür den Typ 'purpose_fix' oder 'location_fix'.

                4. **FEHLENDE DATEN:** Setze fehlende Daten (date, time, purpose, location) auf die **leere Zeichenkette ("")**.
                5. **VORSCHLÄGE:** Wenn der Status "needs_clarification" ist, fülle das **"suggestions"**-Array mit 3 bis 5 präzisen Text-Vorschlägen zur Korrektur oder Klärung, sowie einem "Manuelle Eingabe"-Button.

                **ERFORDERLICHES JSON-FORMAT (MUSS UNMITTELBAR NACH DEM EINLEITUNGSSATZ KOMMEN):**
                \`\`\`json
                {
                  "status": "ok" | "needs_clarification",
                  "comment": "Ein kurzer einleitender/erklärender Satz.",
                  "primaryAppointment": {
                    "date": "YYYY-MM-DD" | "",
                    "time": "HH:MM" | "",
                    "purpose": "Beschreibung des Termins/Betreff",
                    "location": "Ort des Termins (Adresse/Online-Link)" | ""
                  },
                  "suggestions": [
                    { "type": "date_fix" | "time_fix" | "purpose_fix" | "location_fix" | "manual", "text": "Korrekturvorschlag oder 'Manuelle Eingabe'" }
                  ]
                }
                \`\`\`
                6. Verwende immer die Sprache Deutsch.
                `
            }]
        };
        
        // Füge die aktuelle Nutzereingabe (Text und/oder Bild) hinzu
        let userParts = [];
        if (imageFile) {
            userParts.push(await fileToGenerativePart(imageFile));
        }
        if (text) {
            userParts.push({ text: text });
        } 
        
        contents.push({ role: "user", parts: userParts });

        const payload = {
            contents: contents,
            systemInstruction: systemInstruction,
            tools: [{ "google_search": {} }] 
        };

        let responseData = null;
        const maxRetries = 3;
        const baseDelay = 1000;

        // Exponential Backoff für Fehlertoleranz bei API-Aufrufen
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (response.status === 429 || response.status >= 500) {
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, attempt)));
                        continue;
                    }
                } else if (!response.ok) {
                    const errorData = await response.json();
                    return `Fehler beim Senden an Gemini. Status: ${response.status}. Details: ${errorData.error.message}`;
                }

                responseData = await response.json();
                break;
            } catch (error) {
                if (attempt < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, attempt)));
                } else {
                    return "Ein Netzwerkfehler ist aufgetreten. Kann Gemini nicht erreichen.";
                }
            }
        }
        
        const candidateParts = responseData?.candidates?.[0]?.content?.parts;
        let fullResponseText = "";

        if (candidateParts) {
            for (const part of candidateParts) {
                if (part.text) {
                    fullResponseText += part.text;
                }
            }
        }

        if (fullResponseText) {
            return fullResponseText;
        } else {
            console.error("Gemini Response Strukturfehler. Details:", JSON.stringify(responseData));
            return "Es konnte keine gültige Text-Antwort von der KI empfangen werden. (Strukturfehler)";
        }
    }


    // ******************************************************
    // *** 4. CHAT DISPLAY & RENDERING **********************
    // ******************************************************
    
    function handleCorrection(type, text) {
        let correctionPrompt;
        
        if (type === 'manual') {
            // Bei manueller Eingabe den Originaltext des letzten User-Prompts wiederherstellen
            const lastUserMsg = chatHistory.findLast(msg => msg.sender === 'user');
            correctionPrompt = lastUserMsg ? lastUserMsg.text : ""; 

            userInput.value = correctionPrompt;
            userInput.focus();
            toggleSendButton();
        } else {
            // Bei Korrekturvorschlag wird ein neuer Prompt an die KI gesendet
            correctionPrompt = `Bitte verwende diesen Vorschlag zur Korrektur des letzten Termins: ${text}`;
            userInput.value = correctionPrompt; 
            sendMessage(); 
        }
    }

    // Erstellt das HTML für eine einzelne Nachricht im Live-Chat
    function createMessageElement(messageData) {
        const { text, sender, imageUrl, structuredResponse } = messageData;
        
        const row = document.createElement('div');
        row.classList.add('message-row', sender === 'user' ? 'user-message-row' : 'bot-message-row');

        const msgDiv = document.createElement('div');
        msgDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message', 'shadow-sm');

        if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = sender === 'user' ? 'Hochgeladenes Bild' : 'Bild';
            img.classList.add('mb-2');
            msgDiv.appendChild(img);
        }

        let htmlContent = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>').trim();
        let appointment = null;
        let comment = htmlContent;

        // 1. JSON-Block aus dem Text entfernen und Kommentar extrahieren
        if (structuredResponse) {
            appointment = structuredResponse.primaryAppointment;
            // Verwende den explizit extrahierten Kommentar
            comment = structuredResponse.comment.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        } else {
             // Fallback für einfache Textantworten (z.B. API-Fehler)
             const jsonMatch = htmlContent.match(/```json\s*([\s\S]*?)\s*```/m);
             if (jsonMatch) {
                // Nur den Text vor dem JSON-Block anzeigen
                comment = htmlContent.split(jsonMatch[0])[0].trim();
             }
        }
        
        const textNode = document.createElement('p');
        textNode.innerHTML = comment;
        msgDiv.appendChild(textNode);
        
        // 2. Termin-Zusammenfassung und Buttons erstellen (nur für Bot-Nachrichten mit Struktur)
        if (sender === 'model' && appointment) {
            const isClarificationNeeded = structuredResponse.status === 'needs_clarification';
            const hasDateTime = appointment.date && appointment.time;
            
            const dateDisplay = appointment.date || '<span class="text-red-500 font-medium">Datum fehlt</span>';
            const timeDisplay = appointment.time || '<span class="text-red-500 font-medium">Zeit fehlt</span>';
            const purposeDisplay = appointment.purpose || '<span class="text-red-500 font-medium">Zweck fehlt</span>';
            const locationDisplay = appointment.location || '<span class="text-gray-400">Ort fehlt/optional</span>';
            
            const uiHtml = `
                <div class="appointment-summary ${isClarificationNeeded ? 'bg-yellow-50 text-yellow-800 border-yellow-200' : 'bg-green-50 text-green-800 border-green-200'} p-3 mt-3 mb-2 rounded-lg border">
                    <p class="font-bold mb-1 border-b pb-1 ${isClarificationNeeded ? 'border-yellow-200' : 'border-green-200'}">
                        ${isClarificationNeeded ? '⚠️ Korrektur nötig' : '✅ Termin extrahiert'}
                    </p>
                    <ul class="list-none text-sm space-y-1 mt-2">
                        <li><span class="font-semibold w-20 inline-block">Zweck:</span> ${purposeDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Datum:</span> ${dateDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Uhrzeit:</span> ${timeDisplay}</li>
                        <li><span class="font-semibold w-20 inline-block">Ort:</span> ${locationDisplay}</li>
                    </ul>
                </div>
            `;
            // Sicherstellen, dass der Text vor dem Anhängen des UI-HTML am Ende steht
            msgDiv.innerHTML = msgDiv.innerHTML + uiHtml; 
            
            // 3. Korrektur-Buttons hinzufügen
            if (isClarificationNeeded && structuredResponse.suggestions.length > 0) {
                const correctionButtonsContainer = document.createElement('div');
                correctionButtonsContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mt-3', 'p-2', 'bg-gray-100', 'rounded-lg', 'border', 'border-gray-200');
                
                structuredResponse.suggestions.forEach(s => {
                    const btn = document.createElement('button');
                    btn.classList.add('correction-button');
                    
                    let icon = '';
                    switch (s.type) {
                        case 'date_fix': icon = 'calendar_today'; break;
                        case 'time_fix': icon = 'schedule'; break;
                        case 'purpose_fix': icon = 'label'; break;
                        case 'location_fix': icon = 'place'; break;
                        case 'manual': icon = 'keyboard'; btn.classList.add('bg-indigo-100', 'border-indigo-400', 'text-indigo-800'); break;
                        default: icon = 'help_outline';
                    }
                    
                    btn.innerHTML = `<span class="material-icons text-base mr-1">${icon}</span> ${s.text}`;
                    
                    // Bei Klick handleCorrection aufrufen
                    btn.onclick = () => handleCorrection(s.type, s.text === 'Manuelle Eingabe' ? text : s.text);
                    correctionButtonsContainer.appendChild(btn);
                });
                msgDiv.appendChild(correctionButtonsContainer);
            }

            // 4. Kalender-Aktions-Buttons hinzufügen
            if (!isClarificationNeeded && hasDateTime) {
                const actionContainer = document.createElement('div');
                actionContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'mt-3', 'pt-2', 'border-t', 'border-gray-200');
                
                // Google Calendar Link Button
                const gcalUrl = generateGoogleCalendarUrl(appointment);
                const gcalBtn = document.createElement('a');
                gcalBtn.href = gcalUrl;
                gcalBtn.target = '_blank';
                gcalBtn.classList.add('action-button', 'bg-blue-500', 'text-white', 'py-2', 'px-4', 'rounded-full', 'hover:bg-blue-600', 'transition', 'text-sm', 'flex', 'items-center');
                gcalBtn.innerHTML = '<span class="material-icons text-lg mr-1">event</span> In Google Kalender';
                actionContainer.appendChild(gcalBtn);

                // ICS Download Button
                const icsBtn = document.createElement('button');
                icsBtn.classList.add('action-button', 'bg-gray-200', 'text-gray-800', 'py-2', 'px-4', 'rounded-full', 'hover:bg-gray-300', 'transition', 'text-sm', 'flex', 'items-center');
                icsBtn.innerHTML = '<span class="material-icons text-lg mr-1">file_download</span> ICS herunterladen';
                icsBtn.onclick = () => downloadICS(appointment);
                actionContainer.appendChild(icsBtn);

                // Text Kopieren Button
                const copyTextBtn = document.createElement('button');
                copyTextBtn.classList.add('action-button', 'bg-gray-200', 'text-gray-800', 'py-2', 'px-4', 'rounded-full', 'hover:bg-gray-300', 'transition', 'text-sm', 'flex', 'items-center');
                copyTextBtn.innerHTML = '<span class="material-icons text-lg mr-1">content_copy</span> Text kopieren';
                copyTextBtn.onclick = () => copyAppointmentText(appointment, copyTextBtn);
                actionContainer.appendChild(copyTextBtn);

                msgDiv.appendChild(actionContainer);
            }
        }


        row.appendChild(msgDiv);
        return row;
    }

    // Funktion zum Kopieren des Termin-Textes in die Zwischenablage
    function copyAppointmentText(appointment, button) {
        const textToCopy = `Termin-Zusammenfassung:\nZweck: ${appointment.purpose}\nDatum: ${appointment.date}\nUhrzeit: ${appointment.time}\nOrt: ${appointment.location || 'Unbekannt'}`;
        
        const originalText = button.innerHTML;
        const originalBg = button.classList.contains('bg-gray-200') ? 'bg-gray-200' : 'bg-green-500';
        
        try {
            navigator.clipboard.writeText(textToCopy).then(() => {
                button.innerHTML = '<span class="material-icons text-lg mr-1">done</span> Kopiert!';
                button.classList.remove(originalBg, 'bg-gray-200', 'hover:bg-gray-300');
                button.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('bg-green-500', 'text-white', 'hover:bg-green-600');
                    button.classList.add(originalBg, 'hover:bg-gray-300');
                }, 2000);
            }).catch(() => {
                fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg);
            });
        } catch (err) {
            fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg);
        }
    }

    function fallbackCopyTextToClipboard(textToCopy, button, originalText, originalBg) {
        const textArea = document.createElement("textarea");
        textArea.value = textToCopy;
        textArea.style.position = "fixed"; 
        textArea.style.left = "-9999px"; 
        textArea.style.top = "-9999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                button.innerHTML = '<span class="material-icons text-lg mr-1">done</span> Kopiert!';
                button.classList.remove(originalBg, 'bg-gray-200', 'hover:bg-gray-300');
                button.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600');
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.classList.remove('bg-green-500', 'text-white', 'hover:bg-green-600');
                    button.classList.add(originalBg, 'hover:bg-gray-300');
                }, 2000);
            }
        } catch (err) {
            console.error('Kopieren fehlgeschlagen:', err);
        }
        document.body.removeChild(textArea);
    }

    // Funktion zum Herunterladen der ICS-Datei
    function downloadICS(appointment) {
        const icsContent = generateICS(appointment);
        if (!icsContent) return;

        const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        
        // Dateiname basierend auf Zweck und Datum
        const fileName = (appointment.purpose || 'Termin').replace(/\s/g, '_').substring(0, 30).replace(/[^a-zA-Z0-9_]/g, '');
        link.download = `${fileName}_${appointment.date || 'unknown'}.ics`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    function addMessageToChat(text, sender, imageUrl, structuredResponse = null) {
        // Bereinige den Text von einem eventuell vorhandenen JSON-Block, bevor er gespeichert wird,
        // um die Chat-History sauber zu halten (der JSON-Block wird über structuredResponse gespeichert).
        let cleanText = text;
        if (structuredResponse) {
             const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/m);
             if (jsonMatch) {
                // Nur den Text vor dem JSON-Block als Haupttext speichern, falls er den Kommentar enthält
                cleanText = text.split(jsonMatch[0])[0].trim() || structuredResponse.comment;
             }
        }

        const messageData = { text: cleanText, sender, imageUrl, structuredResponse };
        const msgElement = createMessageElement(messageData);
        chatWindow.appendChild(msgElement);
        
        // Speichere die Nachricht im Verlauf
        chatHistory.push(messageData);
        
        saveChatHistory();
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function showLoading() {
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'loading-indicator';
        loadingDiv.classList.add('message-row', 'bot-message-row');
        
        const msgDiv = document.createElement('div');
        // Wichtig: 'bot-message' Klasse hinzufügen
        msgDiv.classList.add('message', 'bot-message'); 
        msgDiv.innerHTML = `
            <div class="loading-content">
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
                <span class="loading-dot"></span>
            </div>
        `;
        
        loadingDiv.appendChild(msgDiv);
        chatWindow.appendChild(loadingDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function hideLoading() {
        const loadingDiv = document.getElementById('loading-indicator');
        if (loadingDiv) {
            loadingDiv.remove();
        }
    }


    // ******************************************************
    // *** 5. HAUPT-LOGIK & EREIGNISSE **********************
    // ******************************************************

    async function sendMessage() {
        const text = userInput.value.trim();
        const imageFile = currentImageFile;

        if (!text && !imageFile) return;
        
        // 1. Nutzernachricht anzeigen und Eingabe leeren
        userInput.value = '';
        // Höhe zurücksetzen, bevor der Button toggelt (wichtig für das Layout)
        userInput.style.height = '40px'; 
        toggleSendButton(); 
        const userImageUrl = imageFile ? URL.createObjectURL(imageFile) : null;
        // Speichere den Originaltext für eventuelle "Manuelle Eingabe"
        addMessageToChat(text, 'user', userImageUrl); 
        
        // 2. Bild-Vorschau zurücksetzen
        resetImageUpload();

        // 3. Ladeanzeige anzeigen
        showLoading();

        // 4. KI-Antwort abrufen
        const responseText = await getGeminiResponse(text, imageFile);
        
        // 5. Ladeanzeige ausblenden
        hideLoading();
        
        // 6. Antwort verarbeiten und anzeigen
        const structuredResponse = extractStructuredResponse(responseText);

        // Wir übergeben den vollen responseText (inkl. JSON-Block) an addMessageToChat,
        // damit es geparst und der Text vor dem JSON-Block als Kommentar verwendet werden kann.
        addMessageToChat(responseText, 'model', null, structuredResponse);
    }
    
    function resetImageUpload() {
        currentImageFile = null;
        fileInput.value = '';
        imagePreviewContainer.classList.add('hidden');
    }

    // --- Chat-Verlauf Speichern/Laden/Löschen ---
    
    function saveChatHistory() {
        // Speichere nur die notwendigen Daten, nicht die temporären Blob-URLs
        const serializableHistory = chatHistory.map(msg => ({
            text: msg.text, // Hier ist jetzt der saubere Text ohne JSON
            sender: msg.sender,
            // Speichern des ImageUrl ist nur für den aktuellen Session-Export sinnvoll,
            // da Blob-URLs nicht über Sessions hinweg funktionieren.
            // Für die Robustheit beim Laden wird imageUrl hier weggelassen oder auf null gesetzt,
            // da die Base64-Daten nicht in localStorage gespeichert werden sollten.
            imageUrl: null, 
            structuredResponse: msg.structuredResponse
        }));
        localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(serializableHistory));
    }

    function loadChatHistory() {
        const savedHistory = localStorage.getItem(CHAT_STORAGE_KEY);
        if (savedHistory) {
            chatHistory = JSON.parse(savedHistory);
            chatHistory.forEach(msg => {
                // Beim Laden müssen wir das createMessageElement mit den gespeicherten Daten verwenden
                // Falls structuredResponse vorhanden ist, wird der Text automatisch repariert
                const msgElement = createMessageElement(msg); 
                chatWindow.appendChild(msgElement);
            });
            chatWindow.scrollTop = chatWindow.scrollHeight; // Beim Laden nach unten scrollen
        }
    }

    function deleteChatConfirmation() {
        // Da wir kein confirm() verwenden dürfen, simulieren wir eine Bestätigungs-Modal
        const modal = document.createElement('div');
        modal.classList.add('fixed', 'inset-0', 'bg-gray-900', 'bg-opacity-75', 'flex', 'items-center', 'justify-center', 'z-50');
        modal.innerHTML = `
            <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm">
                <h3 class="text-xl font-bold mb-3 text-red-600">Chatverlauf löschen?</h3>
                <p class="mb-4 text-gray-700">Sind Sie sicher, dass Sie den gesamten Chatverlauf unwiderruflich löschen möchten?</p>
                <div class="flex justify-end space-x-3">
                    <button id="cancel-delete" class="bg-gray-200 text-gray-700 py-2 px-4 rounded-full hover:bg-gray-300 transition">Abbrechen</button>
                    <button id="confirm-delete" class="bg-red-500 text-white py-2 px-4 rounded-full hover:bg-red-600 transition">Ja, löschen</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);

        document.getElementById('cancel-delete').onclick = () => modal.remove();
        document.getElementById('confirm-delete').onclick = () => {
            modal.remove();
            localStorage.removeItem(CHAT_STORAGE_KEY);
            chatHistory = [];
            chatWindow.innerHTML = '';
            initializeChat(); // Starte den Chat neu mit der Willkommensnachricht
        };
    }
    
    // *** NEUE UND KORRIGIERTE DOWNLOAD-FUNKTION ***
    // Baut den HTML-Export basierend auf dem sauberen chatHistory-Array neu auf.
    function downloadChat() {
        let exportContent = '';
        
        chatHistory.forEach(msg => {
            // Text säubern (Markdown-Fettungen beibehalten)
            let cleanedText = msg.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            let htmlBody = `<p>${cleanedText.replace(/\n/g, '<br>')}</p>`;

            // Wenn strukturiert, verwende den sauberen Kommentar und die Termin-Zusammenfassung
            if (msg.structuredResponse) {
                const appt = msg.structuredResponse.primaryAppointment;
                const isClarificationNeeded = msg.structuredResponse.status === 'needs_clarification';
                
                // Verwende den gespeicherten Kommentar
                const comment = msg.structuredResponse.comment.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                
                const statusClass = isClarificationNeeded ? 'bg-yellow-50 text-yellow-800 border-yellow-200' : 'bg-green-50 text-green-800 border-green-200';
                const statusText = isClarificationNeeded ? '⚠️ Korrektur nötig' : '✅ Termin extrahiert';

                htmlBody = `
                    <p>${comment}</p>
                    <div class="appointment-summary ${statusClass}">
                        <p class="font-bold mb-1 border-b pb-1 ${isClarificationNeeded ? 'border-yellow-200' : 'border-green-200'}">
                            ${statusText}
                        </p>
                        <ul class="list-none text-sm space-y-1 mt-2">
                            <li><span class="font-semibold w-20 inline-block">Zweck:</span> ${appt.purpose || 'Fehlt'}</li>
                            <li><span class="font-semibold w-20 inline-block">Datum:</span> ${appt.date || 'Fehlt'}</li>
                            <li><span class="font-semibold w-20 inline-block">Uhrzeit:</span> ${appt.time || 'Fehlt'}</li>
                            <li><span class="font-semibold w-20 inline-block">Ort:</span> ${appt.location || 'Fehlt'}</li>
                        </ul>
                    </div>
                `;
            }


            const imageHtml = msg.imageUrl ? `<img src="${msg.imageUrl}" alt="Bild" class="max-w-full h-auto rounded mb-2">` : '';

            exportContent += `
                <div class="message-row ${msg.sender === 'user' ? 'user-message-row' : 'bot-message-row'}">
                    <div class="message ${msg.sender === 'user' ? 'user-message' : 'bot-message'} shadow-sm">
                        ${imageHtml}
                        ${htmlBody}
                    </div>
                </div>
            `;
        });

        const fullHtml = `
            <!DOCTYPE html>
            <html lang="de">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Exportierter Chat - AI Termin-Detektiv</title>
                <script src="https://cdn.tailwindcss.com"></script>
                <style>
                    body { font-family: sans-serif; background-color: #f3f4f6; padding: 20px; }
                    .chat-window { max-width: 800px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
                    .message-row { display: flex; margin-bottom: 0.75rem; }
                    .user-message-row { justify-content: flex-end; }
                    .bot-message-row { justify-content: flex-start; }
                    .message { padding: 0.75rem 1rem; border-radius: 1.5rem; max-width: 80%; line-height: 1.4; word-wrap: break-word; font-size: 0.95rem; } 
                    .user-message { background-color: #DCF8C6; margin-left: auto; border-bottom-right-radius: 4px; }
                    .bot-message { background-color: #F9FAFB; border: 1px solid #E5E7EB; border-bottom-left-radius: 4px; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05); }
                    .appointment-summary { padding: 0.75rem; margin-top: 0.75rem; border-radius: 0.5rem; border: 1px solid; }
                    /* Tailwind Farbcodes zur Stilsicherheit kopiert */
                    .bg-green-50 { background-color: #F0FDF4; }
                    .text-green-800 { color: #065F46; }
                    .border-green-200 { border-color: #A7F3D0; }
                    .bg-yellow-50 { background-color: #FFFBEB; }
                    .text-yellow-800 { color: #92400E; }
                    .border-yellow-200 { border-color: #FDE68A; }
                    .message img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 5px; cursor: pointer; }
                </style>
            </head>
            <body>
                <div class="chat-window">
                    <h1 class="text-2xl font-bold mb-4 text-indigo-600">Exportierter Chatverlauf - AI Termin-Detektiv</h1>
                    <p class="text-sm text-gray-500 mb-4">Exportiert am: ${new Date().toLocaleString('de-DE')}</p>
                    ${exportContent}
                </div>
            </body>
            </html>
        `;
        const blob = new Blob([fullHtml], { type: 'text/html;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `chat_export_${new Date().toISOString().slice(0, 10)}.html`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    // *** ENDE KORRIGIERTE DOWNLOAD-FUNKTION ***

    function initializeChat() {
        if (chatHistory.length === 0) {
            let welcomeMessage = "Willkommen beim **AI Termin-Detektiv**! Der API-Schlüssel wird jetzt automatisch und sicher verwaltet, um den 403-Fehler zu vermeiden. Ich bin bereit, Ihre Termin-Infos zu analysieren. Senden Sie mir einfach **Text, einen Screenshot** oder ein **Foto** (z.B. von einem Brief oder einer Kalendereintragung).";
            // Beim Initialisieren fügen wir die Willkommensnachricht hinzu und speichern sie.
            const welcomeMessageData = { text: welcomeMessage, sender: 'model', imageUrl: null, structuredResponse: null };
            const msgElement = createMessageElement(welcomeMessageData);
            chatWindow.appendChild(msgElement);
            chatHistory.push(welcomeMessageData);
            saveChatHistory();
        } else {
            loadChatHistory();
        }
        toggleSendButton();
    }

    // --- Event Listener ---
    
    // Senden bei Enter-Taste, aber Zeilenumbruch bei Shift+Enter
    userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Check, ob der Sende-Button aktiviert werden soll, wenn sich der Text ändert
    userInput.addEventListener('input', toggleSendButton);

    // Bild-Upload verarbeiten
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            currentImageFile = file;
            document.getElementById('image-preview').src = URL.createObjectURL(file);
            document.getElementById('image-filename').textContent = file.name;
            imagePreviewContainer.classList.remove('hidden');
            toggleSendButton(); // Sende-Button aktivieren
        } else {
            resetImageUpload();
            toggleSendButton(); // Sende-Button deaktivieren
        }
    });

    // Bild-Upload abbrechen
    document.getElementById('cancel-upload').addEventListener('click', () => {
        resetImageUpload();
        toggleSendButton();
    });

    // Chat initialisieren, sobald das DOM geladen ist
    window.onload = initializeChat;

</script>
</body>
</html>
